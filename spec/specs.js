// Generated by CoffeeScript 1.6.3
(function() {
  describe('Object', function() {
    var tpl;
    tpl = null;
    beforeEach(function() {
      spyOn(window, 'Beard');
      return tpl = new Beard();
    });
    it('should instantiate', function() {
      return expect(window.Beard).toHaveBeenCalled();
    });
    return it('should not throw exceptions', function() {
      return expect(window.Beard).not.toThrow();
    });
  });

  describe('Template', function() {
    var ret, tpl, tplStr;
    tpl = null;
    tplStr = '<b>Hello world!</b>';
    ret = null;
    beforeEach(function() {
      return tpl = new Beard();
    });
    describe('Set', function() {
      beforeEach(function() {
        spyOn(tpl, 'set').andCallThrough();
        return ret = tpl.set(tplStr);
      });
      it('should have beed called', function() {
        return expect(tpl.set).toHaveBeenCalled();
      });
      it('should not throw exceptions', function() {
        return expect(tpl.set).not.toThrow();
      });
      it('should have been called with proper argument', function() {
        return expect(tpl.set).toHaveBeenCalledWith('<b>Hello world!</b>');
      });
      return it('should return current instance', function() {
        return expect(ret).toBe(tpl);
      });
    });
    describe('Set (empty)', function() {
      beforeEach(function() {
        spyOn(tpl, 'set').andCallThrough();
        return ret = tpl.set();
      });
      it('should have beed called', function() {
        return expect(tpl.set).toHaveBeenCalled();
      });
      it('should not throw exceptions', function() {
        return expect(tpl.set).not.toThrow();
      });
      it('should have been called with no argument', function() {
        return expect(tpl.set).toHaveBeenCalledWith();
      });
      return it('should return current instance', function() {
        return expect(ret).toBe(tpl);
      });
    });
    describe('Get', function() {
      beforeEach(function() {
        tpl.set(tplStr);
        spyOn(tpl, 'get').andCallThrough();
        return ret = tpl.get();
      });
      it('should have beed called', function() {
        return expect(tpl.get).toHaveBeenCalled();
      });
      it('should not throw exceptions', function() {
        return expect(tpl.get).not.toThrow();
      });
      return it('should return current template', function() {
        return expect(ret).toEqual('<b>Hello world!</b>');
      });
    });
    return describe('Get (empty)', function() {
      beforeEach(function() {
        tpl.set();
        spyOn(tpl, 'get').andCallThrough();
        return ret = tpl.get();
      });
      it('should have beed called', function() {
        return expect(tpl.get).toHaveBeenCalled();
      });
      it('should not throw exceptions', function() {
        return expect(tpl.get).not.toThrow();
      });
      return it('should return empty string', function() {
        return expect(ret).toEqual('');
      });
    });
  });

  describe('Render', function() {
    var data, ret, tpl, tplStr;
    tpl = null;
    tplStr = '<b>Hello <%= who %>!</b>';
    data = {
      who: 'world'
    };
    ret = null;
    beforeEach(function() {
      tpl = new Beard();
      return spyOn(tpl, 'render').andCallThrough();
    });
    describe('Render with template and data', function() {
      beforeEach(function() {
        tpl.set(tplStr);
        return ret = tpl.render(data);
      });
      it('should have been called', function() {
        return expect(tpl.render).toHaveBeenCalled();
      });
      it('should have been called with data', function() {
        return expect(tpl.render).toHaveBeenCalledWith(data);
      });
      it('should return string', function() {
        return expect(ret).toEqual(jasmine.any(String));
      });
      return it('should return correct string', function() {
        return expect(ret).toEqual('<b>Hello world!</b>');
      });
    });
    describe('Render with template and no data', function() {
      beforeEach(function() {
        tpl.set(tplStr);
        return ret = tpl.render();
      });
      it('should have been called', function() {
        return expect(tpl.render).toHaveBeenCalled();
      });
      it('should have been called without data', function() {
        return expect(tpl.render).toHaveBeenCalledWith();
      });
      it('should return string', function() {
        return expect(ret).toEqual(jasmine.any(String));
      });
      return it('should return correct string', function() {
        return expect(ret).toEqual('<b>Hello !</b>');
      });
    });
    describe('Render without template but with data', function() {
      beforeEach(function() {
        return ret = tpl.render(data);
      });
      it('should have been called', function() {
        return expect(tpl.render).toHaveBeenCalled();
      });
      it('should have been called with data', function() {
        return expect(tpl.render).toHaveBeenCalledWith(data);
      });
      it('should return string', function() {
        return expect(ret).toEqual(jasmine.any(String));
      });
      return it('should return correct string', function() {
        return expect(ret).toEqual('');
      });
    });
    return describe('Render without template and without data', function() {
      beforeEach(function() {
        return ret = tpl.render();
      });
      it('should have been called', function() {
        return expect(tpl.render).toHaveBeenCalled();
      });
      it('should have been called without data', function() {
        return expect(tpl.render).toHaveBeenCalledWith();
      });
      it('should return string', function() {
        return expect(ret).toEqual(jasmine.any(String));
      });
      return it('should return correct string', function() {
        return expect(ret).toEqual('');
      });
    });
  });

  describe('Get Required', function() {
    var ret, tpl, tplStrE, tplStrEV, tplStrV;
    tpl = null;
    tplStrEV = '<%@ e1 %> <%@ e2 %> <%@ e3 %> <%= v1 %> <%= v2 %> <%= v3 %>';
    tplStrE = '<%@ e1 %> <%@ e2 %> <%@ e3 %>';
    tplStrV = '<%= v1 %> <%= v2 %> <%= v3 %>';
    ret = null;
    beforeEach(function() {
      tpl = new Beard();
      return spyOn(tpl, 'getRequired').andCallThrough();
    });
    describe('Elements and Variables (object template)', function() {
      beforeEach(function() {
        tpl.set(tplStrEV);
        return ret = tpl.getRequired();
      });
      it('should have been called', function() {
        return expect(tpl.getRequired).toHaveBeenCalled();
      });
      it('should return object', function() {
        return expect(ret).toEqual(jasmine.any(Object));
      });
      describe('Elements', function() {
        it('should be an array', function() {
          return expect(ret.elements).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.elements.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.elements).toContain('e1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.elements).not.toContain('v1');
        });
      });
      return describe('Variables', function() {
        it('should be an array', function() {
          return expect(ret.variables).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.variables.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.variables).toContain('v1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.variables).not.toContain('e1');
        });
      });
    });
    describe('Elements and Variables (passed template)', function() {
      beforeEach(function() {
        return ret = tpl.getRequired(tplStrEV);
      });
      it('should have been called', function() {
        return expect(tpl.getRequired).toHaveBeenCalled();
      });
      it('should return object', function() {
        return expect(ret).toEqual(jasmine.any(Object));
      });
      describe('Elements', function() {
        it('should be an array', function() {
          return expect(ret.elements).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.elements.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.elements).toContain('e1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.elements).not.toContain('v1');
        });
      });
      return describe('Variables', function() {
        it('should be an array', function() {
          return expect(ret.variables).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.variables.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.variables).toContain('v1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.variables).not.toContain('e1');
        });
      });
    });
    describe('Elements, not Variables (object template)', function() {
      beforeEach(function() {
        tpl.set(tplStrE);
        return ret = tpl.getRequired();
      });
      it('should have been called', function() {
        return expect(tpl.getRequired).toHaveBeenCalled();
      });
      it('should return object', function() {
        return expect(ret).toEqual(jasmine.any(Object));
      });
      describe('Elements', function() {
        it('should be an array', function() {
          return expect(ret.elements).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.elements.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.elements).toContain('e1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.elements).not.toContain('v1');
        });
      });
      return describe('Variables', function() {
        it('should be an array', function() {
          return expect(ret.variables).toEqual(jasmine.any(Array));
        });
        return it('should be an array with no items', function() {
          return expect(ret.variables.length).toEqual(0);
        });
      });
    });
    describe('Elements, not Variables (passed template)', function() {
      beforeEach(function() {
        return ret = tpl.getRequired(tplStrE);
      });
      it('should have been called', function() {
        return expect(tpl.getRequired).toHaveBeenCalled();
      });
      it('should return object', function() {
        return expect(ret).toEqual(jasmine.any(Object));
      });
      describe('Elements', function() {
        it('should be an array', function() {
          return expect(ret.elements).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.elements.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.elements).toContain('e1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.elements).not.toContain('v1');
        });
      });
      return describe('Variables', function() {
        it('should be an array', function() {
          return expect(ret.variables).toEqual(jasmine.any(Array));
        });
        return it('should be an array with no items', function() {
          return expect(ret.variables.length).toEqual(0);
        });
      });
    });
    describe('Variables, not Elements (object template)', function() {
      beforeEach(function() {
        tpl.set(tplStrV);
        return ret = tpl.getRequired();
      });
      it('should have been called', function() {
        return expect(tpl.getRequired).toHaveBeenCalled();
      });
      it('should return object', function() {
        return expect(ret).toEqual(jasmine.any(Object));
      });
      describe('Elements', function() {
        it('should be an array', function() {
          return expect(ret.elements).toEqual(jasmine.any(Array));
        });
        return it('should be an array with no items', function() {
          return expect(ret.elements.length).toEqual(0);
        });
      });
      return describe('Variables', function() {
        it('should be an array', function() {
          return expect(ret.variables).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.variables.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.variables).toContain('v1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.variables).not.toContain('e1');
        });
      });
    });
    describe('Variables, not Elements (passed template)', function() {
      beforeEach(function() {
        return ret = tpl.getRequired(tplStrV);
      });
      it('should have been called', function() {
        return expect(tpl.getRequired).toHaveBeenCalled();
      });
      it('should return object', function() {
        return expect(ret).toEqual(jasmine.any(Object));
      });
      describe('Elements', function() {
        it('should be an array', function() {
          return expect(ret.elements).toEqual(jasmine.any(Array));
        });
        return it('should be an array with no items', function() {
          return expect(ret.elements.length).toEqual(0);
        });
      });
      return describe('Variables', function() {
        it('should be an array', function() {
          return expect(ret.variables).toEqual(jasmine.any(Array));
        });
        it('should be an array with three items', function() {
          return expect(ret.variables.length).toEqual(3);
        });
        it('should contain correct value', function() {
          return expect(ret.variables).toContain('v1');
        });
        return it('should not contain incorrect value', function() {
          return expect(ret.variables).not.toContain('e1');
        });
      });
    });
    return describe('No Variables, no Elements', function() {
      beforeEach(function() {
        return ret = tpl.getRequired();
      });
      it('should have been called', function() {
        return expect(tpl.getRequired).toHaveBeenCalled();
      });
      it('should return object', function() {
        return expect(ret).toEqual(jasmine.any(Object));
      });
      describe('Elements', function() {
        it('should be an array', function() {
          return expect(ret.elements).toEqual(jasmine.any(Array));
        });
        return it('should be an array with no items', function() {
          return expect(ret.elements.length).toEqual(0);
        });
      });
      return describe('Variables', function() {
        it('should be an array', function() {
          return expect(ret.variables).toEqual(jasmine.any(Array));
        });
        return it('should be an array with no items', function() {
          return expect(ret.variables.length).toEqual(0);
        });
      });
    });
  });

  describe('Compile', function() {
    var data, elements, ret, tpl, tplStr, tplStrErr;
    tpl = null;
    tplStr = 'Hello <%@ e1 %> <%@ e2 %> <%@ e3 %> <%= v1 %> <%= v2 %> <%= v3 %> world';
    tplStrErr = 'Hello <%@ e1 %> <%@ e2 %> <%@ e3 %> <%= v1 <%= v2 %> <%= v3 %> world';
    data = {
      v1: 'v1',
      v2: 'v2',
      v3: 'v3'
    };
    elements = {
      e1: 'e1',
      e2: 'e2',
      e3: 'e3'
    };
    ret = null;
    beforeEach(function() {
      tpl = new Beard();
      return spyOn(tpl, 'compile').andCallThrough();
    });
    describe('Elements, Variables and Template', function() {
      beforeEach(function() {
        tpl.addElements(elements);
        return ret = tpl.compile(tplStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.compile).toHaveBeenCalled();
      });
      return it('should return correct compiled template', function() {
        return expect(ret).toEqual('Hello e1 e2 e3 v1 v2 v3 world');
      });
    });
    describe('Elements, no Variables and Template', function() {
      beforeEach(function() {
        tpl.addElements(elements);
        return ret = tpl.compile(tplStr);
      });
      it('should have been called', function() {
        return expect(tpl.compile).toHaveBeenCalled();
      });
      return it('should return correct compiled template', function() {
        return expect(ret).toEqual('Hello e1 e2 e3 world');
      });
    });
    describe('Variables, no Elements and Template', function() {
      beforeEach(function() {
        return ret = tpl.compile(tplStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.compile).toHaveBeenCalled();
      });
      return it('should return correct compiled template', function() {
        return expect(ret).toEqual('Hello Element e1 not found Element e2 not found Element e3 not found v1 v2 v3 world');
      });
    });
    describe('Template, no Variables and no Elements', function() {
      beforeEach(function() {
        return ret = tpl.compile(tplStr);
      });
      it('should have been called', function() {
        return expect(tpl.compile).toHaveBeenCalled();
      });
      return it('should return correct compiled template', function() {
        return expect(ret).toEqual('Element e1 not found Element e2 not found Element e3 not found');
      });
    });
    describe('Variables, Elements, no Template', function() {
      beforeEach(function() {
        tpl.addElements(elements);
        return ret = tpl.compile('', data);
      });
      it('should have been called', function() {
        return expect(tpl.compile).toHaveBeenCalled();
      });
      return it('should return correct compiled template', function() {
        return expect(ret).toEqual('');
      });
    });
    return describe('Invalid template', function() {
      beforeEach(function() {
        tpl.addElements(elements);
        return ret = tpl.compile(tplStrErr, data);
      });
      it('should have been called', function() {
        return expect(tpl.compile).toHaveBeenCalled();
      });
      return it('should throw error', function() {
        return expect(tpl.compile).toThrow();
      });
    });
  });

  describe('List', function() {
    var data, ret, tpl, tplStr;
    tpl = null;
    tplStr = 'Hello <%= v1 %> <%= v2 %> <%= v3 %> world';
    data = [
      {
        v1: 'v1'
      }, {
        v2: 'v2'
      }, {
        v3: 'v3'
      }
    ];
    ret = null;
    beforeEach(function() {
      tpl = new Beard();
      spyOn(tpl, 'list').andCallThrough();
      return ret = tpl.list(tplStr, data);
    });
    it('should have been called', function() {
      return expect(tpl.list).toHaveBeenCalled();
    });
    return it('should return correct compiled template', function() {
      return expect(ret).toEqual('Hello v1 v2 v3 world');
    });
  });

  describe('Evaluate', function() {
    var commentStr, data, elementStr, elements, funcStr, keyStr, ret, str, tpl, variableStr;
    tpl = null;
    ret = null;
    commentStr = '# comment';
    funcStr = '= func()';
    keyStr = '= test.key';
    variableStr = '= variable';
    elementStr = '@ element';
    str = 'Not an element';
    data = {
      func: function() {
        return 'Function call';
      },
      test: {
        key: 'Test key'
      },
      variable: 'Test variable'
    };
    elements = {
      element: 'Test element'
    };
    beforeEach(function() {
      tpl = new Beard();
      return spyOn(tpl, 'evaluate').andCallThrough();
    });
    describe('Comment', function() {
      beforeEach(function() {
        return ret = tpl.evaluate(commentStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluate).toHaveBeenCalled();
      });
      return it('should return an empty string', function() {
        return expect(ret).toEqual('');
      });
    });
    describe('Function', function() {
      beforeEach(function() {
        spyOn(data, 'func').andCallThrough();
        return ret = tpl.evaluate(funcStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluate).toHaveBeenCalled();
      });
      it('function should have been called', function() {
        return expect(data.func).toHaveBeenCalled();
      });
      return it('should return the result of the call', function() {
        return expect(ret).toEqual('Function call');
      });
    });
    describe('Key', function() {
      beforeEach(function() {
        return ret = tpl.evaluate(keyStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluate).toHaveBeenCalled();
      });
      return it('should return the correct value', function() {
        return expect(ret).toEqual('Test key');
      });
    });
    describe('Variable', function() {
      beforeEach(function() {
        return ret = tpl.evaluate(variableStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluate).toHaveBeenCalled();
      });
      return it('should return the correct value', function() {
        return expect(ret).toEqual('Test variable');
      });
    });
    describe('Element', function() {
      beforeEach(function() {
        tpl.addElements(elements);
        spyOn(tpl, 'evaluateElement').andCallThrough();
        return ret = tpl.evaluate(elementStr);
      });
      it('should have been called', function() {
        return expect(tpl.evaluate).toHaveBeenCalled();
      });
      it('should call evaluateElement method', function() {
        return expect(tpl.evaluateElement).toHaveBeenCalled();
      });
      return it('should return the correct value', function() {
        return expect(ret).toEqual('Test element');
      });
    });
    return describe('Not a parseable element', function() {
      beforeEach(function() {
        return ret = tpl.evaluate(str);
      });
      it('should have been called', function() {
        return expect(tpl.evaluate).toHaveBeenCalled();
      });
      return it('should return the string unchanged', function() {
        return expect(ret).toEqual('Not an element');
      });
    });
  });

  describe('Evaluate Variable', function() {
    var data, noVarDefStr, noVarStr, ret, tpl, varDefStr, varStr;
    tpl = null;
    ret = null;
    varStr = 'v1';
    varDefStr = 'v1 | Default value';
    noVarStr = 'x1';
    noVarDefStr = 'x1 | Default value';
    data = {
      v1: 'v1'
    };
    beforeEach(function() {
      tpl = new Beard();
      return spyOn(tpl, 'evaluateVariable').andCallThrough();
    });
    describe('Existing Variable without Default', function() {
      beforeEach(function() {
        return ret = tpl.evaluateVariable(varStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluateVariable).toHaveBeenCalled();
      });
      return it('should return variable\'s value', function() {
        return expect(ret).toEqual('v1');
      });
    });
    describe('Existing Variable with Default', function() {
      beforeEach(function() {
        return ret = tpl.evaluateVariable(varDefStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluateVariable).toHaveBeenCalled();
      });
      return it('should return variable\'s value', function() {
        return expect(ret).toEqual('v1');
      });
    });
    describe('Inexisting Variable without Default', function() {
      beforeEach(function() {
        return ret = tpl.evaluateVariable(noVarStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluateVariable).toHaveBeenCalled();
      });
      return it('should return an empty string', function() {
        return expect(ret).toEqual('');
      });
    });
    return describe('Inexisting Variable with Default', function() {
      beforeEach(function() {
        return ret = tpl.evaluateVariable(noVarDefStr, data);
      });
      it('should have been called', function() {
        return expect(tpl.evaluateVariable).toHaveBeenCalled();
      });
      return it('should return the default value', function() {
        return expect(ret).toEqual('Default value');
      });
    });
  });

  describe('Add Elements', function() {
    var elements, ret, tpl;
    tpl = null;
    ret = null;
    elements = {
      e1: 'e1',
      e2: 'e2',
      e3: 'e3'
    };
    beforeEach(function() {
      tpl = new Beard();
      spyOn(tpl, 'addElements').andCallThrough();
      return ret = tpl.addElements(elements);
    });
    it('should have been called', function() {
      return expect(tpl.addElements).toHaveBeenCalled();
    });
    it('should return the current instance', function() {
      return expect(ret).toBe(tpl);
    });
    it('should add correct first element', function() {
      return expect(ret.elements.e1).toEqual('e1');
    });
    it('should add correct second element', function() {
      return expect(ret.elements.e2).toEqual('e2');
    });
    return it('should add correct third element', function() {
      return expect(ret.elements.e3).toEqual('e3');
    });
  });

  describe('Add Element', function() {
    var element, id, ret, tpl;
    tpl = null;
    ret = null;
    id = 'e1';
    element = 'element';
    beforeEach(function() {
      tpl = new Beard();
      spyOn(tpl, 'addElement').andCallThrough();
      return ret = tpl.addElement(id, element);
    });
    it('should have been called', function() {
      return expect(tpl.addElement).toHaveBeenCalled();
    });
    it('should return the current instance', function() {
      return expect(ret).toBe(tpl);
    });
    it('should add element', function() {
      return expect(ret.elements.e1).toBeDefined();
    });
    return it('should add element with correct value', function() {
      return expect(ret.elements.e1).toEqual('element');
    });
  });

  describe('Remove Element', function() {
    var elements, ret, tpl;
    tpl = null;
    ret = null;
    elements = {
      e1: 'e1',
      e2: 'e2'
    };
    beforeEach(function() {
      tpl = new Beard('', {}, elements);
      return spyOn(tpl, 'remElement').andCallThrough();
    });
    describe('Before', function() {
      return it('element should exist', function() {
        return expect(tpl.elements.e1).toBeDefined();
      });
    });
    return describe('After', function() {
      beforeEach(function() {
        return ret = tpl.remElement('e1');
      });
      it('should have been called', function() {
        return expect(tpl.remElement).toHaveBeenCalled();
      });
      it('should return the current object instance', function() {
        return expect(ret).toBe(tpl);
      });
      it('element shouldn\'t exist', function() {
        return expect(tpl.elements.e1).toBeUndefined();
      });
      return it('unremoved element should exist', function() {
        return expect(tpl.elements.e2).toBeDefined();
      });
    });
  });

  describe('Remove all Elements', function() {
    var elements, ret, tpl;
    tpl = null;
    ret = null;
    elements = {
      e1: 'e1',
      e2: 'e2'
    };
    beforeEach(function() {
      tpl = new Beard('', {}, elements);
      spyOn(tpl, 'remElements').andCallThrough();
      return ret = tpl.remElements();
    });
    it('should have been called', function() {
      return expect(tpl.remElements).toHaveBeenCalled();
    });
    it('should return the current object instance', function() {
      return expect(ret).toBe(tpl);
    });
    return it('should have empty elements', function() {
      return expect(tpl.elements).toEqual({});
    });
  });

  describe('Evaluate Element', function() {
    var data, elements, ret, tpl;
    tpl = null;
    ret = null;
    elements = {
      e1: 'e1',
      e2: 'Hello <%= v1 %> world'
    };
    data = {
      v1: 'v1',
      v2: 'v2'
    };
    beforeEach(function() {
      tpl = new Beard;
      return spyOn(tpl, 'evaluateElement').andCallThrough();
    });
    describe('Plain Elements', function() {
      beforeEach(function() {
        tpl.addElements(elements);
        return ret = tpl.evaluateElement('e1');
      });
      it('should have been called', function() {
        return expect(tpl.evaluateElement).toHaveBeenCalled();
      });
      return it('should return the correct value', function() {
        return expect(ret).toEqual('e1');
      });
    });
    return describe('Elements with', function() {
      describe('Object\'s variables', function() {
        beforeEach(function() {
          tpl = new Beard('', data, elements);
          spyOn(tpl, 'evaluateElement').andCallThrough();
          return ret = tpl.evaluateElement('e2');
        });
        it('should have been called', function() {
          return expect(tpl.evaluateElement).toHaveBeenCalled();
        });
        return it('should return the correct value', function() {
          return expect(ret).toEqual('Hello v1 world');
        });
      });
      return describe('Passed variables', function() {
        beforeEach(function() {
          tpl = new Beard('', {}, elements);
          spyOn(tpl, 'evaluateElement').andCallThrough();
          return ret = tpl.evaluateElement('e2', data);
        });
        it('should have been called', function() {
          return expect(tpl.evaluateElement).toHaveBeenCalled();
        });
        return it('should return the correct value', function() {
          return expect(ret).toEqual('Hello v1 world');
        });
      });
    });
  });

}).call(this);
