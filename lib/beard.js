//     Beard.js
//
//     The MIT License (MIT)
//     Copyright (c) 2013 NextUser
(function(undefined) {
    "use strict";
    var Beard;
    // Constructor
    // ------------------
    // Parameters:
    //
    // * `tpl` - Template
    // * `data` - Data
    // * `elements` - Elements
    //
    //
    //     var beard = new Beard(tpl, data, elements);
    //
    Beard = function(tpl, data, elements) {
        this.tpl = tpl || '';
        this.dat = data || {};
        this.UDEF = undefined;
        this.elements = elements || {};
    };
    Beard.prototype = {
        // Set the template
        set: function(tpl) {
            this.tpl = tpl || '';
            return this;
        },
        // Get the template
        get: function() {
            return this.tpl;
        },
        // Render the template
        render: function(data) {
            if (data) {
                this.dat = data;
            }
            return Beard.compile(this.tpl, {
                elements: this.elements,
                variables: this.dat
            });
        },
        // Returns an object containing an array of variables, and an array of elements:
        getRequired: function(tpl) {
            tpl = tpl || this.tpl;
            return Beard.getRequired(tpl);
        },
        // Add many template elements
        addElements: function(elements) {
            var k;
            for (k in elements) {
                if (elements.hasOwnProperty(k)) {
                    this.elements[k] = elements[k];
                }
            }
            return this;
        },
        // Add a template element
        addElement: function(id, element) {
            this.elements[id] = element;
            return this;
        },
        // Remove a template element
        remElement: function(id) {
            delete this.elements[id];
            return this;
        },
        // Remove all elements
        remElements: function() {
            this.elements = {};
            return this;
        },
        // Add some data in the data object (may be a variable, a function)
        addVariable: function(key, value) {
            this.dat[key] = value;
            return this;
        },
        // Remove some data in the data object
        remVariable: function(key) {
            delete this.dat[key];
            return this;
        },
        // Remove everything in the data object
        // FIXME: Change name?
        resetDataObject: function() {
            this.dat = {};
            return this;
        }
    };
    // Beard.Parser
    // ------------
    /* parser generated by jison 0.4.13 */
    /*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
    var parser = (function() {
        var parser = {
            trace: function trace() {},
            yy: {},
            symbols_: {
                "error": 2,
                "root": 3,
                "statements": 4,
                "EOF": 5,
                "program": 6,
                "simpleInverse": 7,
                "OPEN_INVERSE": 8,
                "CLOSE": 9,
                "statement": 10,
                "openBlock": 11,
                "closeBlock": 12,
                "elementTag": 13,
                "variableTag": 14,
                "CONTENT": 15,
                "COMMENT": 16,
                "OPEN": 17,
                "ID": 18,
                "segments": 19,
                "hash": 20,
                "hashSegment": 21,
                "compOperator": 22,
                "param": 23,
                "EQUALS": 24,
                "GREATER": 25,
                "LESSER": 26,
                "AND": 27,
                "OR": 28,
                "END_BLOCK": 29,
                "OPEN_ELEMENT": 30,
                "OPEN_VARIABLE": 31,
                "var": 32,
                "func": 33,
                "ALT": 34,
                "SEP": 35,
                "OP": 36,
                "args": 37,
                "CP": 38,
                "COMMA": 39,
                "STRING": 40,
                "INTEGER": 41,
                "BOOLEAN": 42,
                "$accept": 0,
                "$end": 1
            },
            terminals_: {
                2: "error",
                5: "EOF",
                8: "OPEN_INVERSE",
                9: "CLOSE",
                15: "CONTENT",
                16: "COMMENT",
                17: "OPEN",
                18: "ID",
                24: "EQUALS",
                25: "GREATER",
                26: "LESSER",
                27: "AND",
                28: "OR",
                29: "END_BLOCK",
                30: "OPEN_ELEMENT",
                31: "OPEN_VARIABLE",
                34: "ALT",
                35: "SEP",
                36: "OP",
                38: "CP",
                39: "COMMA",
                40: "STRING",
                41: "INTEGER",
                42: "BOOLEAN"
            },
            productions_: [0, [3, 2],
                [6, 2],
                [6, 3],
                [6, 2],
                [6, 1],
                [6, 1],
                [6, 0],
                [7, 2],
                [4, 1],
                [4, 2],
                [10, 3],
                [10, 1],
                [10, 1],
                [10, 1],
                [10, 1],
                [11, 4],
                [11, 4],
                [20, 1],
                [21, 3],
                [21, 3],
                [21, 3],
                [22, 1],
                [22, 1],
                [22, 1],
                [22, 1],
                [22, 1],
                [12, 1],
                [13, 3],
                [14, 3],
                [14, 3],
                [32, 1],
                [32, 3],
                [32, 3],
                [32, 5],
                [33, 4],
                [33, 6],
                [33, 6],
                [33, 8],
                [19, 3],
                [19, 1],
                [37, 3],
                [37, 1],
                [37, 0],
                [23, 1],
                [23, 1],
                [23, 1]
            ],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */ , $$ /* vstack */ , _$ /* lstack */ ) {
                /* this == yyval */
                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        return new yy.ProgramNode($$[$0 - 1]);
                        break;
                    case 2:
                        this.$ = new yy.ProgramNode([], $$[$0]);
                        break;
                    case 3:
                        this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0]);
                        break;
                    case 4:
                        this.$ = new yy.ProgramNode($$[$0 - 1], []);
                        break;
                    case 5:
                        this.$ = new yy.ProgramNode($$[$0]);
                        break;
                    case 6:
                        this.$ = new yy.ProgramNode([]);
                        break;
                    case 7:
                        this.$ = new yy.ProgramNode([]);
                        break;
                    case 9:
                        this.$ = [$$[$0]];
                        break;
                    case 10:
                        $$[$0 - 1].push($$[$0]);
                        this.$ = $$[$0 - 1];
                        break;
                    case 11:
                        this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1], $$[$0]);
                        break;
                    case 12:
                        this.$ = new yy.ElementNode($$[$0]);
                        break;
                    case 13:
                        this.$ = $$[$0];
                        break;
                    case 14:
                        this.$ = new yy.ContentNode($$[$0]);
                        break;
                    case 15:
                        this.$ = new yy.CommentNode($$[$0]);
                        break;
                    case 16:
                        this.$ = [$$[$0 - 2], new yy.DataNode($$[$0 - 1])];
                        break;
                    case 17:
                        this.$ = [$$[$0 - 2], $$[$0 - 1]];
                        break;
                    case 18:
                        this.$ = new yy.HashNode($$[$0]);
                        break;
                    case 19:
                        this.$ = [new yy.DataNode($$[$0 - 2]), $$[$0 - 1], $$[$0]];
                        break;
                    case 20:
                        this.$ = [$$[$0 - 2], $$[$0 - 1], new yy.DataNode($$[$0])];
                        break;
                    case 21:
                        this.$ = [new yy.DataNode($$[$0 - 2]), $$[$0 - 1], new yy.DataNode($$[$0])];
                        break;
                    case 27:
                        this.$ = $$[$0];
                        break;
                    case 28:
                        this.$ = $$[$0 - 1];
                        break;
                    case 29:
                        this.$ = $$[$0 - 1];
                        break;
                    case 30:
                        this.$ = $$[$0 - 1];
                        break;
                    case 31:
                        this.$ = new yy.DataNode($$[$0]);
                        break;
                    case 32:
                        this.$ = new yy.DataNode($$[$0 - 2], $$[$0]);
                        break;
                    case 33:
                        this.$ = new yy.DataNode([$$[$0 - 2]].concat($$[$0]));
                        break;
                    case 34:
                        this.$ = new yy.DataNode([$$[$0 - 4]].concat($$[$0 - 2]), $$[$0]);
                        break;
                    case 35:
                        this.$ = new yy.FuncNode($$[$0 - 3], $$[$0 - 1]);
                        break;
                    case 36:
                        this.$ = new yy.FuncNode($$[$0 - 5], $$[$0 - 3], $$[$0]);
                        break;
                    case 37:
                        this.$ = new yy.FuncNode([$$[$0 - 5]].concat($$[$0 - 3]), $$[$0 - 1]);
                        break;
                    case 38:
                        this.$ = new yy.FuncNode([$$[$0 - 7]].concat($$[$0 - 5]), $$[$0 - 3], $$[$0]);
                        break;
                    case 39:
                        $$[$0 - 2].push($$[$0]);
                        this.$ = $$[$0 - 2];
                        break;
                    case 40:
                        this.$ = [$$[$0]];
                        break;
                    case 41:
                        $$[$0 - 2].push($$[$0]);
                        this.$ = $$[$0 - 2];
                        break;
                    case 42:
                        this.$ = [$$[$0]];
                        break;
                    case 43:
                        this.$ = [];
                        break;
                    case 44:
                        this.$ = new yy.StringNode($$[$0]);
                        break;
                    case 45:
                        this.$ = new yy.IntegerNode($$[$0]);
                        break;
                    case 46:
                        this.$ = new yy.BooleanNode($$[$0]);
                        break;
                }
            },
            table: [{
                3: 1,
                4: 2,
                10: 3,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                30: [1, 10],
                31: [1, 11]
            }, {
                1: [3]
            }, {
                5: [1, 12],
                10: 13,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                30: [1, 10],
                31: [1, 11]
            }, {
                5: [2, 9],
                8: [2, 9],
                15: [2, 9],
                16: [2, 9],
                17: [2, 9],
                29: [2, 9],
                30: [2, 9],
                31: [2, 9]
            }, {
                4: 16,
                6: 14,
                7: 15,
                8: [1, 17],
                10: 3,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                29: [2, 7],
                30: [1, 10],
                31: [1, 11]
            }, {
                5: [2, 12],
                8: [2, 12],
                15: [2, 12],
                16: [2, 12],
                17: [2, 12],
                29: [2, 12],
                30: [2, 12],
                31: [2, 12]
            }, {
                5: [2, 13],
                8: [2, 13],
                15: [2, 13],
                16: [2, 13],
                17: [2, 13],
                29: [2, 13],
                30: [2, 13],
                31: [2, 13]
            }, {
                5: [2, 14],
                8: [2, 14],
                15: [2, 14],
                16: [2, 14],
                17: [2, 14],
                29: [2, 14],
                30: [2, 14],
                31: [2, 14]
            }, {
                5: [2, 15],
                8: [2, 15],
                15: [2, 15],
                16: [2, 15],
                17: [2, 15],
                29: [2, 15],
                30: [2, 15],
                31: [2, 15]
            }, {
                18: [1, 18]
            }, {
                18: [1, 19]
            }, {
                18: [1, 23],
                19: 22,
                32: 20,
                33: 21
            }, {
                1: [2, 1]
            }, {
                5: [2, 10],
                8: [2, 10],
                15: [2, 10],
                16: [2, 10],
                17: [2, 10],
                29: [2, 10],
                30: [2, 10],
                31: [2, 10]
            }, {
                12: 24,
                29: [1, 25]
            }, {
                4: 26,
                10: 3,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                29: [2, 6],
                30: [1, 10],
                31: [1, 11]
            }, {
                7: 27,
                8: [1, 17],
                10: 13,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                29: [2, 5],
                30: [1, 10],
                31: [1, 11]
            }, {
                9: [1, 28]
            }, {
                18: [1, 23],
                19: 29,
                20: 30,
                21: 31,
                23: 32,
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                9: [1, 36]
            }, {
                9: [1, 37]
            }, {
                9: [1, 38],
                35: [1, 39]
            }, {
                9: [2, 31],
                34: [1, 40],
                35: [1, 42],
                36: [1, 41]
            }, {
                9: [2, 40],
                24: [2, 40],
                25: [2, 40],
                26: [2, 40],
                27: [2, 40],
                28: [2, 40],
                34: [2, 40],
                35: [2, 40],
                36: [2, 40]
            }, {
                5: [2, 11],
                8: [2, 11],
                15: [2, 11],
                16: [2, 11],
                17: [2, 11],
                29: [2, 11],
                30: [2, 11],
                31: [2, 11]
            }, {
                5: [2, 27],
                8: [2, 27],
                15: [2, 27],
                16: [2, 27],
                17: [2, 27],
                29: [2, 27],
                30: [2, 27],
                31: [2, 27]
            }, {
                10: 13,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                29: [2, 2],
                30: [1, 10],
                31: [1, 11]
            }, {
                4: 43,
                10: 3,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                29: [2, 4],
                30: [1, 10],
                31: [1, 11]
            }, {
                15: [2, 8],
                16: [2, 8],
                17: [2, 8],
                29: [2, 8],
                30: [2, 8],
                31: [2, 8]
            }, {
                9: [1, 44],
                22: 45,
                24: [1, 46],
                25: [1, 47],
                26: [1, 48],
                27: [1, 49],
                28: [1, 50],
                35: [1, 42]
            }, {
                9: [1, 51]
            }, {
                9: [2, 18]
            }, {
                22: 52,
                24: [1, 46],
                25: [1, 47],
                26: [1, 48],
                27: [1, 49],
                28: [1, 50]
            }, {
                9: [2, 44],
                24: [2, 44],
                25: [2, 44],
                26: [2, 44],
                27: [2, 44],
                28: [2, 44],
                35: [2, 44],
                38: [2, 44],
                39: [2, 44]
            }, {
                9: [2, 45],
                24: [2, 45],
                25: [2, 45],
                26: [2, 45],
                27: [2, 45],
                28: [2, 45],
                35: [2, 45],
                38: [2, 45],
                39: [2, 45]
            }, {
                9: [2, 46],
                24: [2, 46],
                25: [2, 46],
                26: [2, 46],
                27: [2, 46],
                28: [2, 46],
                35: [2, 46],
                38: [2, 46],
                39: [2, 46]
            }, {
                5: [2, 28],
                8: [2, 28],
                15: [2, 28],
                16: [2, 28],
                17: [2, 28],
                29: [2, 28],
                30: [2, 28],
                31: [2, 28]
            }, {
                5: [2, 29],
                8: [2, 29],
                15: [2, 29],
                16: [2, 29],
                17: [2, 29],
                29: [2, 29],
                30: [2, 29],
                31: [2, 29]
            }, {
                5: [2, 30],
                8: [2, 30],
                15: [2, 30],
                16: [2, 30],
                17: [2, 30],
                29: [2, 30],
                30: [2, 30],
                31: [2, 30]
            }, {
                18: [1, 23],
                19: 53
            }, {
                23: 54,
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                23: 56,
                37: 55,
                38: [2, 43],
                39: [2, 43],
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                18: [1, 57]
            }, {
                10: 13,
                11: 4,
                13: 5,
                14: 6,
                15: [1, 7],
                16: [1, 8],
                17: [1, 9],
                29: [2, 3],
                30: [1, 10],
                31: [1, 11]
            }, {
                8: [2, 16],
                15: [2, 16],
                16: [2, 16],
                17: [2, 16],
                29: [2, 16],
                30: [2, 16],
                31: [2, 16]
            }, {
                18: [1, 23],
                19: 59,
                23: 58,
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                18: [2, 22],
                40: [2, 22],
                41: [2, 22],
                42: [2, 22]
            }, {
                18: [2, 23],
                40: [2, 23],
                41: [2, 23],
                42: [2, 23]
            }, {
                18: [2, 24],
                40: [2, 24],
                41: [2, 24],
                42: [2, 24]
            }, {
                18: [2, 25],
                40: [2, 25],
                41: [2, 25],
                42: [2, 25]
            }, {
                18: [2, 26],
                40: [2, 26],
                41: [2, 26],
                42: [2, 26]
            }, {
                8: [2, 17],
                15: [2, 17],
                16: [2, 17],
                17: [2, 17],
                29: [2, 17],
                30: [2, 17],
                31: [2, 17]
            }, {
                18: [1, 23],
                19: 60
            }, {
                9: [2, 33],
                34: [1, 61],
                35: [1, 42],
                36: [1, 62]
            }, {
                9: [2, 32]
            }, {
                38: [1, 63],
                39: [1, 64]
            }, {
                38: [2, 42],
                39: [2, 42]
            }, {
                9: [2, 39],
                24: [2, 39],
                25: [2, 39],
                26: [2, 39],
                27: [2, 39],
                28: [2, 39],
                34: [2, 39],
                35: [2, 39],
                36: [2, 39]
            }, {
                9: [2, 19]
            }, {
                9: [2, 21],
                35: [1, 42]
            }, {
                9: [2, 20],
                35: [1, 42]
            }, {
                23: 65,
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                23: 56,
                37: 66,
                38: [2, 43],
                39: [2, 43],
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                9: [2, 35],
                34: [1, 67],
                35: [2, 35]
            }, {
                23: 68,
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                9: [2, 34]
            }, {
                38: [1, 69],
                39: [1, 64]
            }, {
                23: 70,
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                38: [2, 41],
                39: [2, 41]
            }, {
                9: [2, 37],
                34: [1, 71],
                35: [2, 37]
            }, {
                9: [2, 36],
                35: [2, 36]
            }, {
                23: 72,
                40: [1, 33],
                41: [1, 34],
                42: [1, 35]
            }, {
                9: [2, 38],
                35: [2, 38]
            }],
            defaultActions: {
                12: [2, 1],
                31: [2, 18],
                54: [2, 32],
                58: [2, 19],
                65: [2, 34]
            },
            parseError: function parseError(str, hash) {
                if (hash.recoverable) {
                    this.trace(str);
                } else {
                    throw new Error(str);
                }
            },
            parse: function parse(input) {
                var self = this,
                    stack = [0],
                    vstack = [null],
                    lstack = [],
                    table = this.table,
                    yytext = '',
                    yylineno = 0,
                    yyleng = 0,
                    recovering = 0,
                    TERROR = 2,
                    EOF = 1;
                var args = lstack.slice.call(arguments, 1);
                this.lexer.setInput(input);
                this.lexer.yy = this.yy;
                this.yy.lexer = this.lexer;
                this.yy.parser = this;
                if (typeof this.lexer.yylloc == 'undefined') {
                    this.lexer.yylloc = {};
                }
                var yyloc = this.lexer.yylloc;
                lstack.push(yyloc);
                var ranges = this.lexer.options && this.lexer.options.ranges;
                if (typeof this.yy.parseError === 'function') {
                    this.parseError = this.yy.parseError;
                } else {
                    this.parseError = Object.getPrototypeOf(this).parseError;
                }

                function popStack(n) {
                    stack.length = stack.length - 2 * n;
                    vstack.length = vstack.length - n;
                    lstack.length = lstack.length - n;
                }

                function lex() {
                    var token;
                    token = self.lexer.lex() || EOF;
                    if (typeof token !== 'number') {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    } else {
                        if (symbol === null || typeof symbol == 'undefined') {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                        var errStr = '';
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push('\'' + this.terminals_[p] + '\'');
                            }
                        }
                        if (this.lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                        } else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                        }
                        this.parseError(errStr, {
                            text: this.lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: this.lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0) {
                                    recovering--;
                                }
                            } else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {
                                first_line: lstack[lstack.length - (len || 1)].first_line,
                                last_line: lstack[lstack.length - 1].last_line,
                                first_column: lstack[lstack.length - (len || 1)].first_column,
                                last_column: lstack[lstack.length - 1].last_column
                            };
                            if (ranges) {
                                yyval._$.range = [
                                    lstack[lstack.length - (len || 1)].range[0],
                                    lstack[lstack.length - 1].range[1]
                                ];
                            }
                            r = this.performAction.apply(yyval, [
                                yytext,
                                yyleng,
                                yylineno,
                                this.yy,
                                action[1],
                                vstack,
                                lstack
                            ].concat(args));
                            if (typeof r !== 'undefined') {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            }
        };
        /* generated by jison-lex 0.2.1 */
        var lexer = (function() {
            var lexer = {
                EOF: 1,
                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    } else {
                        throw new Error(str);
                    }
                },
                // resets the lexer, sets new input
                setInput: function(input) {
                    this._input = input;
                    this._more = this._backtrack = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = {
                        first_line: 1,
                        first_column: 0,
                        last_line: 1,
                        last_column: 0
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [0, 0];
                    }
                    this.offset = 0;
                    return this;
                },
                // consumes and returns one char from the input
                input: function() {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    } else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) {
                        this.yylloc.range[1]++;
                    }
                    this._input = this._input.slice(1);
                    return ch;
                },
                // unshifts one char (or a string) into the input
                unput: function(ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);
                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);
                    if (lines.length - 1) {
                        this.yylineno -= lines.length - 1;
                    }
                    var r = this.yylloc.range;
                    this.yylloc = {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    this.yyleng = this.yytext.length;
                    return this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function() {
                    this._more = true;
                    return this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function() {
                    if (this.options.backtrack_lexer) {
                        this._backtrack = true;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                    return this;
                },
                // retain first n characters of the match
                less: function(n) {
                    this.unput(this.match.slice(n));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function() {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function() {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function() {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function(match, indexed_rule) {
                    var token,
                        lines,
                        backup;
                    if (this.options.backtrack_lexer) {
                        // save context
                        backup = {
                            yylineno: this.yylineno,
                            yylloc: {
                                first_line: this.yylloc.first_line,
                                last_line: this.last_line,
                                first_column: this.yylloc.first_column,
                                last_column: this.yylloc.last_column
                            },
                            yytext: this.yytext,
                            match: this.match,
                            matches: this.matches,
                            matched: this.matched,
                            yyleng: this.yyleng,
                            offset: this.offset,
                            _more: this._more,
                            _input: this._input,
                            yy: this.yy,
                            conditionStack: this.conditionStack.slice(0),
                            done: this.done
                        };
                        if (this.options.ranges) {
                            backup.yylloc.range = this.yylloc.range.slice(0);
                        }
                    }
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno += lines.length;
                    }
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._backtrack = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) {
                        this.done = false;
                    }
                    if (token) {
                        return token;
                    } else if (this._backtrack) {
                        // recover context
                        for (var k in backup) {
                            this[k] = backup[k];
                        }
                        return false; // rule action called reject() implying the next rule should be tested instead.
                    }
                    return false;
                },
                // return next match in input
                next: function() {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) {
                        this.done = true;
                    }
                    var token,
                        match,
                        tempMatch,
                        index;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (this.options.backtrack_lexer) {
                                token = this.test_match(tempMatch, rules[i]);
                                if (token !== false) {
                                    return token;
                                } else if (this._backtrack) {
                                    match = false;
                                    continue; // rule action called reject() implying a rule MISmatch.
                                } else {
                                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                    return false;
                                }
                            } else if (!this.options.flex) {
                                break;
                            }
                        }
                    }
                    if (match) {
                        token = this.test_match(match, rules[index]);
                        if (token !== false) {
                            return token;
                        }
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    } else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                },
                // return next match that has a token
                lex: function lex() {
                    var r = this.next();
                    if (r) {
                        return r;
                    } else {
                        return this.lex();
                    }
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function popState() {
                    var n = this.conditionStack.length - 1;
                    if (n > 0) {
                        return this.conditionStack.pop();
                    } else {
                        return this.conditionStack[0];
                    }
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function _currentRules() {
                    if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    } else {
                        return this.conditions["INITIAL"].rules;
                    }
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function topState(n) {
                    n = this.conditionStack.length - 1 - Math.abs(n || 0);
                    if (n >= 0) {
                        return this.conditionStack[n];
                    } else {
                        return "INITIAL";
                    }
                },
                // alias for begin(condition)
                pushState: function pushState(condition) {
                    this.begin(condition);
                },
                // return the number of states currently on the stack
                stateStackSize: function stateStackSize() {
                    return this.conditionStack.length;
                },
                options: {},
                performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    function strip(start, end) {
                        return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                    }
                    var YYSTATE = YY_START;
                    switch ($avoiding_name_collisions) {
                        case 0:
                            this.begin('beard');
                            if (yy_.yytext) return 15;
                            break;
                        case 1:
                            return 15;
                            break;
                        case 2:
                            strip(0, 2);
                            this.popState();
                            return 16;
                            break;
                        case 3:
                            return 31;
                            break;
                        case 4:
                            return 30;
                            break;
                        case 5:
                            this.popState();
                            this.begin('com');
                            break;
                        case 6:
                            strip(3, 5);
                            this.popState();
                            return 16;
                            break;
                        case 7:
                            strip(6, 9);
                            this.popState();
                            return 29;
                            break;
                        case 8:
                            return 8;
                            break;
                        case 9:
                            return 17;
                            break;
                        case 10:
                            return 28;
                            break;
                        case 11:
                            return 34;
                            break;
                        case 12:
                            return 35;
                            break;
                        case 13:
                            return 39;
                            break;
                        case 14:
                            return 36;
                            break;
                        case 15:
                            return 38;
                            break;
                        case 16:
                            return 24;
                            break;
                        case 17:
                            return 25;
                            break;
                        case 18:
                            return 26;
                            break;
                        case 19:
                            return 27;
                            break;
                        case 20:
                            /* ignore whitespace */
                                break;
                        case 21:
                            this.popState();
                            return 9;
                            break;
                        case 22:
                            yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                            return 40;
                            break;
                        case 23:
                            yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                            return 40;
                            break;
                        case 24:
                            return 41;
                            break;
                        case 25:
                            return 42;
                            break;
                        case 26:
                            return 42;
                            break;
                        case 27:
                            return 18;
                            break;
                        case 28:
                            return 'INVALID';
                            break;
                        case 29:
                            return 5;
                            break;
                    }
                },
                rules: [/^(?:[^\x00]*?(?=(<%)))/, /^(?:[^\x00]+)/, /^(?:[\s\S]*?%>)/, /^(?:<%=)/, /^(?:<%@)/, /^(?:<%#)/, /^(?:<%#[\s\S]*?%>)/, /^(?:<% end([a-zA-Z_][a-zA-Z0-9_]*) %>)/, /^(?:<%\s*else\b)/, /^(?:<%)/, /^(?:\|\|)/, /^(?:\|)/, /^(?:\.)/, /^(?:,)/, /^(?:\()/, /^(?:\))/, /^(?:===|==|=)/, /^(?:>)/, /^(?:<)/, /^(?:&&)/, /^(?:\s+)/, /^(?:%>)/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:-?[0-9]+)/, /^(?:true\b)/, /^(?:false\b)/, /^(?:([a-zA-Z_][a-zA-Z0-9_]*))/, /^(?:.)/, /^(?:$)/],
                conditions: {
                    "beard": {
                        "rules": [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
                        "inclusive": false
                    },
                    "com": {
                        "rules": [2],
                        "inclusive": false
                    },
                    "INITIAL": {
                        "rules": [0, 1, 29],
                        "inclusive": true
                    }
                }
            };
            return lexer;
        })();
        parser.lexer = lexer;

        function Parser() {
            this.yy = {};
        }
        Parser.prototype = parser;
        parser.Parser = Parser;
        return new Parser;
    })();
    Beard.Parser = parser;
    // Beard.AST
    // ---------
    Beard.AST = {};
    Beard.AST.ProgramNode = function(statements, inverse) {
        this.type = 'program';
        this.statements = statements;
        if (inverse) {
            this.inverse = new Beard.AST.ProgramNode(inverse);
        }
    };
    Beard.AST.ElementNode = function(id) {
        this.type = 'element';
        this.id = id;
    };
    Beard.AST.ContentNode = function(string) {
        this.type = 'content';
        this.string = string;
    };
    Beard.AST.DataNode = function(variable, def) {
        this.type = 'data';
        this.variable = variable;
        this.def = def || '';
    };
    Beard.AST.CommentNode = function(comment) {
        this.type = 'comment';
        this.comment = comment;
    };
    Beard.AST.IdNode = function(id) {
        this.type = 'ID';
        this.id = id;
    };
    Beard.AST.BlockNode = function(helper, program, close) {
        if (helper[0] !== close) {
            throw new Error(helper[0] + " doesn't match " + close);
        }
        this.type = 'block';
        this.helper = helper;
        this.program = program;
    };
    Beard.AST.StringNode = function(string) {
        this.type = 'STRING';
        this.string = this.stringModeValue = string;
    };
    Beard.AST.FuncNode = function(func, args, def) {
        this.type = 'func';
        this.func = func;
        this.args = args;
        this.def = def;
    };
    Beard.AST.IntegerNode = function(integer) {
        this.type = 'INTEGER';
        this.integer = integer;
        this.stringModeValue = Number(integer);
    };
    Beard.AST.BooleanNode = function(bool) {
        this.type = 'BOOLEAN';
        this.bool = bool;
        this.stringModeValue = bool === 'true';
    };
    Beard.AST.HashNode = function(pairs) {
        this.type = 'hash';
        this.pairs = pairs;
    };
    // Beard.Compiler
    // --------------
    var Compiler = Beard.Compiler = function() {};
    Compiler.prototype = {
        compiler: Compiler,
        compile: function(program, options) {
            var statements = program.statements,
                i = 0,
                l = statements.length,
                statement;
            options.elements = options.elements || {};
            options.variables = options.variables || {};
            this.options = options;
            this.result = [];
            for (i; i < l; i += 1) {
                statement = statements[i];
                console.log(statement);
                this.result.push(this[statement.type](statement));
            }
            return this;
        },
        // Compile element
        element: function(element) {
            if (this.options.elements[element.id]) {
                return Beard.evaluateElement(this.options.elements[element.id], this.options);
            }
            return "Element " + element.id + " not found";
        },
        // Compile content node
        content: function(string) {
            return string.string;
        },
        // Compile data variable tag
        data: function(data) {
            var i = 0,
                l = data.variable.length,
                v = this.options.variables,
                key;
            for (; i < l; i += 1) {
                key = data.variable[i];
                // Handle Funciton-Variable mixture
                if (typeof key !== 'string' && key.constructor === Beard.AST.FuncNode) {
                    v = this[key.type](key);
                } else {
                    v = v[key];
                }
                if (typeof v === 'undefined') {
                    if (data.def) {
                        v = this[data.def.type](data.def);
                    } else {
                        v = '';
                    }
                    break;
                }
            }
            return v;
        },
        // Compile function call
        func: function(func) {
            var i = 0,
                l = func.func.length,
                parent,
                fn = parent = this.options.variables,
                key;
            for (; i < l; i += 1) {
                key = func.func[i];
                parent = fn;
                // Handle Funciton-Variable mixture
                if (typeof key !== 'string' && key.constructor === Beard.AST.FuncNode) {
                    fn = this[key.type](key);
                } else {
                    fn = fn[key];
                }
                if (typeof fn === 'undefined') {
                    if (func.def) {
                        return this[func.def.type](func.def);
                    }
                    return;
                }
            }
            // `parent` is the function's `this`:
            //
            //     data = {
            //         first_name: 'John',
            //         last_name: 'Doe',
            //         full_name: function () {
            //             return this.first_name + ' ' + this.last_name;
            //             // return "John Doe"
            //         },
            //         nested: {
            //             first_name: 'Robert',
            //             last_name: 'Roe',
            //             full_name: function () {
            //                 return this.first_name + ' ' + this.last_name;
            //                 // return "Robert Roe"
            //             }
            //         }
            //     }
            return fn.apply(parent, this.args(func.args));
        },
        // Compile function's arguments
        args: function(args) {
            return args.map(function(v) {
                return this[v.type](v);
            }, this);
        },
        // Compile comment
        comment: function() {
            return '';
        },
        // Compile block instructions code
        block: function(block) {
            var helper,
                data,
                program;
            // Compile helper and its arguments or data
            data = block.helper.map(function(item) {
                if (typeof item !== 'string') {
                    return this[item.type](item);
                }
                return item;
            }, this);
            helper = data[0];
            data = data[1];
            program = block.program;
            return Beard.BlockHelpers[helper](data, program, this.options);
        },
        // Compile hash
        hash: function(hash) {
            return hash.pairs.map(function(item) {
                if (typeof item !== 'string') {
                    return this[item.type](item, true);
                }
                return item;
            }, this);
        },
        // Compile string parameter
        STRING: function(string) {
            return string.string;
        },
        // Compile integer parameter
        //
        // If `strict` is `True`, it returns the `Number` value,
        // otherwise, its `String` representation. The default is `False`.
        INTEGER: function(integer, strict) {
            strict = !! strict;
            return strict ? integer.stringModeValue : integer.integer;
        },
        // Compile boolean parameter
        //
        // If `strict` is `True`, it returns the `Boolean` value,
        // otherwise, its `String` representation. The default is `False`.
        BOOLEAN: function(bool, strict) {
            strict = !! strict;
            return strict ? bool.stringModeValue : bool.bool;
        }
    };
    // Helpers
    // -------
    Beard.BlockHelpers = Beard.Helpers = {};
    Beard.registerHelper = function(name, func, is_block) {
        is_block = !! is_block;
        if (is_block) {
            Beard.BlockHelpers[name] = func;
        } else {
            Beard.Helpers[name] = func;
        }
    };
    // ### Core Helpers
    Beard.registerHelper('foreach', function(data, program, options) {
        var key,
            value,
            l,
            program_options,
            env,
            result = [];
        data = data || {};
        // Iterate through the array
        if (data instanceof Array) {
            l = data.length;
            for (key = 0; key < l; key++) {
                program_options = options;
                value = data[key];
                program_options.variables.key = key;
                program_options.variables.value = value;
                env = new Compiler().compile(program, program_options);
                result = result.concat(env.result);
            }
        } else if (data instanceof Object) {
            for (key in data) {
                if (data.hasOwnProperty(key)) {
                    value = data[key];
                    program_options = options;
                    value = data[key];
                    program_options.variables.key = key;
                    program_options.variables.value = value;
                    env = new Compiler().compile(program, program_options);
                    result = result.concat(env.result);
                }
            }
        } else {
            throw new Error('Data should be either Object or Array');
        }
        return result.join('');
    }, true);
    Beard.registerHelper('if', function(data, program, options) {
        var env,
            result = [],
            positive;
        if (typeof data === 'object' &&
            data instanceof Array &&
            data.length === 3 && /^(={1,3}|<|>|&&|\|\|)$/.test(data[1])) {
            // We've got hash
            switch (data[1]) {
                case '=':
                case '==':
                    positive = data[0] == data[2];
                    break;
                case '===':
                    positive = data[0] === data[2];
                    break;
                case '<':
                    positive = data[0] < data[2];
                    break;
                case '>':
                    positive = data[0] > data[2];
                    break;
                case '&&':
                    positive = data[0] && data[2];
                    break;
                case '||':
                    positive = data[0] || data[2];
                    break;
            }
        } else {
            // Otherwise, let's check if passed data is truthy/falsy
            positive = !! data;
        }
        if (positive) {
            env = new Compiler().compile(program, options);
            result = env.result;
        } else {
            env = new Compiler().compile(program.inverse, options);
            result = env.result;
        }
        return result.join('');
    }, true);
    Beard.parse = function(input) {
        Beard.Parser.yy = Beard.AST;
        return Beard.Parser.parse(input);
    };
    Beard.getRequired = function(input) {
        var ast = Beard.parse(input);
        return ast.statements.reduce(function(previous, current) {
            switch (current.constructor) {
                case Beard.AST.DataNode:
                    previous.variables.push(current.variable[0]);
                    break;
                case Beard.AST.ElementNode:
                    previous.elements.push(current.id);
                    break;
            }
            return previous;
        }, {
            variables: [],
            elements: []
        });
    };
    Beard.compile = function(input, options) {
        options = options || {};
        var ast = Beard.parse(input),
            env = new Compiler().compile(ast, options);
        return env.result.join('');
    };
    Beard.evaluateElement = function(input, options) {
        return Beard.compile(input, options);
    };
    this.Beard = Beard;
}).call(this);
